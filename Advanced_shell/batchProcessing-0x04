#!/bin/bash

# Parallel Data Fetching Script - Task 4
# Fetches Pokémon data in parallel using background processes
# Properly handles process management and waits for completion
# Uses jobs and kill for background process control

# List of Pokémon to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# API base URL
API_BASE_URL="https://pokeapi.co/api/v2/pokemon"

# Error log file
ERROR_FILE="parallel_errors.txt"

# Success log file
SUCCESS_FILE="parallel_success.txt"

# Timeout for processes (in seconds)
TIMEOUT=30

# Cleanup function to kill all background jobs on exit
cleanup() {
    echo ""
    echo "Cleaning up background processes..."
    
    # Get all background job PIDs
    local job_pids=$(jobs -p)
    
    if [ -n "$job_pids" ]; then
        echo "Killing remaining jobs..."
        for pid in $job_pids; do
            if kill -0 ${pid} 2>/dev/null; then
                echo "  Terminating process ${pid}"
                kill ${pid} 2>/dev/null
            fi
        done
        
        # Wait a moment for graceful termination
        sleep 1
        
        # Force kill if still running
        for pid in $job_pids; do
            if kill -0 ${pid} 2>/dev/null; then
                echo "  Force killing process ${pid}"
                kill -9 ${pid} 2>/dev/null
            fi
        done
    fi
    
    echo "Cleanup complete"
}

# Set up trap to cleanup on script exit or interrupt
trap cleanup EXIT INT TERM

# Clear log files
> "${ERROR_FILE}"
> "${SUCCESS_FILE}"

# Array to store background process PIDs
declare -a PIDS=()

echo "Starting parallel data fetching for Pokémon..."
echo "Processing ${#POKEMON_LIST[@]} Pokémon in parallel..."
echo ""

# Function to fetch a single Pokémon (runs in background)
fetch_pokemon_parallel() {
    local pokemon=$1
    local output_file="${pokemon}.json"
    local api_url="${API_BASE_URL}/${pokemon}"
    
    # Make API request
    HTTP_CODE=$(curl -s -S -w "%{http_code}" -o "${output_file}" "${api_url}" 2>/dev/null)
    CURL_EXIT=$?
    
    # Check if request was successful
    if [ ${CURL_EXIT} -eq 0 ] && [ "${HTTP_CODE}" -eq 200 ]; then
        echo "${pokemon}: Success" >> "${SUCCESS_FILE}"
        echo "✓ ${pokemon} fetched successfully"
    else
        echo "${pokemon}: Failed (HTTP ${HTTP_CODE}, Exit ${CURL_EXIT})" >> "${ERROR_FILE}"
        echo "✗ ${pokemon} failed"
        rm -f "${output_file}"
    fi
}

# Launch parallel background processes for each Pokémon
for pokemon in "${POKEMON_LIST[@]}"; do
    echo "Launching fetch process for ${pokemon}..."
    
    # Run fetch in background and capture PID
    fetch_pokemon_parallel "${pokemon}" &
    PID=$!
    
    # Store the PID
    PIDS+=($PID)
    
    echo "  Started background process (PID: ${PID})"
done

echo ""
echo "All fetch processes launched. Waiting for completion..."
echo ""

# Display running background jobs
echo "Active background jobs:"
jobs -l
echo ""

# Monitor jobs periodically
echo "Monitoring background processes..."
MONITOR_COUNT=0
while [ $(jobs -p | wc -l) -gt 0 ] && [ ${MONITOR_COUNT} -lt ${TIMEOUT} ]; do
    ACTIVE_JOBS=$(jobs -p | wc -l)
    if [ ${ACTIVE_JOBS} -gt 0 ]; then
        echo "  ${ACTIVE_JOBS} processes still running..."
        sleep 1
        ((MONITOR_COUNT++))
    fi
done

# Check for timeout
if [ ${MONITOR_COUNT} -ge ${TIMEOUT} ]; then
    echo ""
    echo "WARNING: Timeout reached. Killing remaining processes..."
    for pid in $(jobs -p); do
        if kill -0 ${pid} 2>/dev/null; then
            echo "  Killing process ${pid}"
            kill ${pid} 2>/dev/null
        fi
    done
fi

echo ""
echo "All fetch processes launched. Waiting for completion..."
echo ""

# Display running background jobs
echo "Active background jobs:"
jobs -l
echo ""

# Wait for all background processes to complete
for pid in "${PIDS[@]}"; do
    # Check if process is still running before waiting
    if kill -0 ${pid} 2>/dev/null; then
        echo "Waiting for process ${pid}..."
        # Wait for specific process
        wait ${pid}
        EXIT_CODE=$?
        
        if [ ${EXIT_CODE} -eq 0 ]; then
            echo "Process ${pid} completed successfully"
        else
            echo "Process ${pid} completed with errors (exit code: ${EXIT_CODE})"
        fi
    else
        echo "Process ${pid} already completed"
    fi
done

# Check for any remaining jobs
REMAINING_JOBS=$(jobs -p)
if [ -n "$REMAINING_JOBS" ]; then
    echo ""
    echo "Waiting for remaining background jobs..."
    jobs -l
    wait
fi

echo ""
echo "All processes completed!"
echo ""

# Count successes and failures
SUCCESS_COUNT=0
FAIL_COUNT=0

if [ -s "${SUCCESS_FILE}" ]; then
    SUCCESS_COUNT=$(wc -l < "${SUCCESS_FILE}")
fi

if [ -s "${ERROR_FILE}" ]; then
    FAIL_COUNT=$(wc -l < "${ERROR_FILE}")
fi

echo "==================================="
echo "Parallel Fetch Summary:"
echo "==================================="
echo "Successfully fetched: ${SUCCESS_COUNT} Pokémon"
echo "Failed: ${FAIL_COUNT} Pokémon"
echo ""

# Display successful downloads
if [ ${SUCCESS_COUNT} -gt 0 ]; then
    echo "Successful downloads:"
    cat "${SUCCESS_FILE}"
    echo ""
fi

# Display errors if any
if [ ${FAIL_COUNT} -gt 0 ]; then
    echo "Failed downloads:"
    cat "${ERROR_FILE}"
    echo ""
    echo "Errors logged in ${ERROR_FILE}"
fi

# Clean up log files
rm -f "${SUCCESS_FILE}"

exit 0
